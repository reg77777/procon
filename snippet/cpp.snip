snippet bellman_ford.cpp 	
	
	struct E{
	  int to;
	  int from;
	  int cost;
	};
	
	vector<int_fast64_t>bellman_ford(vector<E>g,int n,int s,int_fast64_t inf){
	  vector<int_fast64_t>d(n,inf);
	  d[s]=0;
	  for(int i=0;i<n-1;i++){
	    for(auto e:g){
	      if(d[e.from]==inf)continue;
	      d[e.to]=min(d[e.to],d[e.from]+e.cost);
	    }
	  }
	  for(auto e:g){
	    if(d[e.from]==inf)continue;
	    if(d[e.from]+e.cost<d[e.to])return vector<int_fast64_t>();
	  }
	  return d;
	}
snippet dijkstra.cpp 	
	
	struct E{
	  int to;
	  int_fast64_t cost;
	};
	
	vector<int_fast64_t>dijkstra(vector<vector<E>>g,int s,int_fast64_t inf){
	  vector<int_fast64_t>d(g.size(),inf);
	  using T=pair<int_fast64_t,int>;
	  using C=vector<T>;
	  using Cmp=greater<T>;
	  priority_queue<T,C,Cmp>q; 
	  d[s]=0;
	  q.push({d[s],s});
	  while(!q.empty()){
	    int_fast64_t cost=q.top().first;
	    int from=q.top().second;
	    q.pop();
	    if(d[from]!=cost)continue;
	    for(auto e:g[from]){
	      int_fast64_t next_cost=e.cost+cost;
	      if(d[e.to]>next_cost){
	        d[e.to]=next_cost;
	        q.push({d[e.to],e.to});
	      }
	    }
	  }
	  return d;
	}
snippet dlca.cpp 	
	
	
	struct DLCA{
	  int LOG;
	  vector<int>dep;
	  vector<vector<int>>g;
	  vector<vector<int>>table;
	
	  DLCA(vector<vector<int>>&g):g(g),dep(g.size()),LOG(32-__builtin_clz(g.size())){
	    table.assign(LOG,vector<int>(g.size(),-1));
	  }
	
	  //ÂÖ®„Å¶„ÅÆËëâ„ÅÆË¶™„Çítable[0]„Å´Ë®òÈå≤
	  void dfs(int idx,int par,int d){
	    //idx„ÅÆ‰∏Ä„Å§‰∏ä„ÅÆË¶™
	    table[0][idx]=par;
	    //Ê†π„Åã„Çâ„ÅÆË∑ùÈõ¢
	    dep[idx]=d;
	    for(auto to:g[idx]){
	      if(to!=par)dfs(to,idx,d+1);
	    }
	  }
	
	  void build(){
	    dfs(0,-1,0);
	    //LOG=floor(log(g.size()));
	    //„ÉÄ„Éñ„É™„É≥„Ç∞
	    for(int k=0;k+1<LOG;k++){
	      for(int i=0;i<table[k].size();i++){
	        if(table[k][i]==-1)table[k+1][i]=-1;
	        else table[k+1][i]=table[k][table[k][i]];
	      }
	    }
	  }
	
	  int query(int u,int v){
	    //Ê∑±„Åï„ÇíÊèÉ„Åà„Çã
	    if(dep[u]>dep[v])swap(u,v);
	    for(int i=LOG-1;i>=0;i--){
	      if(((dep[v]-dep[u])>>i)&1)v=table[i][v];
	    }
	    if(u==v)return u;
	    //Âêå„Åò„Å´„Å™„Çã„Åæ„Åß„Å°„Çá„Å£„Å®„Åö„Å§Ëøë„Å•„Åè
	    for(int i=LOG-1;i>=0;i--){
	      if(table[i][u]!=table[i][v]){
	        u=table[i][u];
	        v=table[i][v];
	      }
	    }
	    return table[0][u];
	  }
	
	};
snippet fordfulkerson.cpp 	
	
	
	struct edge{
	  int to,cap,rev;
	};
	
	struct Flow{
	  vector<vector<edge>>G;
	  vector<bool>used;
	  Flow(vector<vector<edge>>g){
	    int N=g.size();
	    used.resize(N,false);
	    for(int i=0;i<N;i++){
	      for(auto it:g[i])add_edge(i,it.to,it.cap);
	    }
	  };
	  void add_edge(int from,int to,int cap){
	    G[from].push_back({to,cap,(int)G[to].size()});
	    G[to].push_back({from,0,(int)G[from].size()-1});
	  }
	  int max_flow(int s,int g){
	    int flow=0;
	    while(true){
	      fill(used.begin(),used.end(),false);
	      int f=dfs(s,g,INF);
	      if(f==0)return flow;
	      flow+=f;
	    }
	  }
	  int dfs(int s,int g,int val){
	    if(s==g)return val;
	    used[s]=true;
	    for(auto e:G[s]){
	      if(!used[e.to]&&e.cap>0){
	        int d=dfs(e.to,g,min(val,e.cap));
	        if(d>0){
	          e.cap-=d;
	          G[e.to][e.rev].cap+=d;
	          return d;
	        }
	      }
	    }
	    return 0;
	  }
	};
snippet gcd.cpp 	
	
	
	int_fast64_t gcd(int_fast64_t a,int_fast64_t b){
	  if(b==0)return a;
	  return gcd(b,a%b);
	}
snippet lca.cpp 	
	
	struct LCA{
	  int r; 
	  vector<int>par;
	  vector<int>d;
	  vector<vector<int>>g;
	  LCA(vector<vector<int>>g,int r):g(g),r(r){
	    int N=g.size();
	    par.resize(N,0);
	    d.resize(N,0);
	    dfs(r,-1,0);
	  }
	  void dfs(int x,int p,int val){
	    par[x]=p;
	    d[x]=val;
	    for(auto it:g[x]){
	      if(it!=p)dfs(it,x,val+1);
	    }
	  }
	  int query(int x,int y){
	    while(d[x]>d[y])x=par[x];
	    while(d[x]<d[y])y=par[y];
	    while(x!=y)x=par[x],y=par[y];
	    return x;
	  }
	};
snippet lcm.cpp 	
	
	int_fast64_t gcd(int_fast64_t a,int_fast64_t b){
	  if(b==0)return a;
	  return gcd(b,a%b);
	}
	
	int_fast64_t lcm(int_fast64_t a,int_fast64_t b){
	  return a*b/gcd(a,b);
	}
snippet modcomb.cpp 	
	
	template<uint_fast64_t m>
	struct Mcomb{
	  using i64=uint_fast64_t;
	  vector<i64>f;  //$B3,>h(B
	  vector<i64>finv; //$B3,>h$N5U85(B
	  vector<i64>inv;  //$B5U85(B
	
	  Mcomb(i64 max){
	    f.resize(max+1,0);
	    finv.resize(max+1,0);
	    inv.resize(max+1,0);
	    f[0]=f[1]=1;
	    finv[0]=finv[1]=1;
	    inv[1]=1;
	    for(int i=2;i<=max;i++){
	      f[i]=(f[i-1]*i%m)%m;
	      inv[i]=m-inv[m%i]*(m/i)%m;
	      finv[i]=finv[i-1]*inv[i]%m;
	    }
	  }
	
	  //nCr=n!/r!(n-r)!
	  i64 slove(i64 n,i64 r){
	    if(n<r)return 0;
	    if(n<0||r<0)return 0;
	    return f[n]*(finv[r]*finv[n-r]%m)%m;
	  }
	};
snippet modint.cpp 	
	
	template<uint_fast64_t mod>
	struct modint{
	  using i64=int_fast64_t;
	  i64 a;
	  constexpr modint(const i64 x=0) noexcept:a(x%mod){}
	
	  constexpr modint operator+(const modint obj)const noexcept{return modint(*this)+=obj;}
	  constexpr modint operator-(const modint obj)const noexcept{return modint(*this)-=obj;}
	  constexpr modint operator*(const modint obj)const noexcept{return modint(*this)*=obj;}
	  constexpr modint operator/(const modint obj)const noexcept{return modint(*this)/=obj;}
	
	  constexpr modint&operator+=(const modint obj)noexcept{
	    a+=obj.a;
	    if(a>=mod)a-=mod;
	    return *this;
	  }
	  constexpr modint&operator++(const modint obj)noexcept{
	    a++;
	    if(a>=mod)a-=mod;
	    return *this;
	  } 
	  constexpr modint&operator-=(const modint obj)noexcept{
	    if(a<obj.a)a+=mod;
	    a-=obj.a;
	    return *this;
	  }
	  constexpr modint&operator--(const modint obj)noexcept{
	    if(a<1)a+=mod;
	    a--;
	    return *this;
	  } 
	  constexpr modint&operator*=(const modint obj)noexcept{
	    a=a*obj.a%mod;
	    return *this;
	  }
	  constexpr modint&operator/=(modint obj)noexcept{
	    //a^(-1)=a^(mod-2)
	    i64 exp=mod-2;
	    while(exp){
	      if(exp%2)*this*=obj;
	      obj*=obj;
	      exp/=2;
	    }
	    return *this;
	  }
	
	  friend ostream&operator<<(ostream&os,const modint&obj)noexcept{
	    return os<<obj.a;
	  }
	  friend istream&operator<<(istream&is,const modint&obj)noexcept{
	    i64 i;
	    obj=modint<mod>(i);
	    return(is);
	  }
	};
snippet modpow.cpp 	
	
	template<uint_fast64_t m>
	int_fast64_t mpow(int_fast64_t x,int_fast64_t n){
	  using i64=int_fast64_t;
	  if(x==0)return 1;
	  if(x%2)return ((n%m)*(mpow<m>(n,x-1)%m))%m;
	  else {
	    i64 half=mpow<m>(n,x/2)%m;
	    return (half*half)%m;
	  }
	}
snippet segtree.cpp 	
	
	template<typename T=int_fast64_t>
	struct segT{
	  vector<T>v;
	  using F=function<T(T,T)>;
	  F f;
	  T e;
	  int sz;
	  segT(int n){
	    f=[](T a,T b){return a+b;};
	    e=0;
	    sz=1;while(sz<n)sz*=2;
	    v.resize(2*sz-1,e);
	  }
	  segT(int n,T e,F f):e(e),f(f){
	    sz=1;while(sz<n)sz*=2;
	    v.resize(2*sz-1,e);
	  }
	  void add(int x,T val){
	    x+=sz-1;
	    v[x]=f(v[x],val);
	    while(x>0){
	      x=(x-1)/2;
	      v[x]=f(v[2*x+1],v[2*x+2]);
	    }
	  }
	  void update(int x,T val){
	    x+=sz-1;
	    v[x]=val;
	    while(x>0){
	      x=(x-1)/2;
	      v[x]=f(v[2*x+1],v[2*x+2]);
	    }
	  }
	  T sum(int a,int b,int l=0,int r=-1,int k=0){
	    if(r==-1)r=sz;
	    if(a<=l&&r<=b)return v[k];
	    if(b<=l||r<=a)return e;
	    T lval=sum(a,b,l,(l+r)/2,2*k+1);
	    T rval=sum(a,b,(l+r)/2,r,2*k+2);
	    return f(lval,rval);
	  }
	};
snippet uf.cpp 	
	
	struct UF{
	  vector<int>p; //p[i]=$B%N!<%I(Bi$B$N?F(B
	  vector<int>r; //rank[i]=$B%N!<%I(Bi$B$N%i%s%/(B
	  UF(int sz){
	    r.resize(sz,0);
	    p.resize(sz);
	    for(int i=0;i<sz;i++)p[i]=i;
	  }
	  void u(int x,int y){ //1
	    x=root(x);
	    y=root(y);
	    if(r[x]==r[y])r[x]++;
	    if(r[x]>r[y])p[y]=x;
	    else p[x]=y;
	  }
	  int root(int x){
	    if(p[x]==x)return x;
	    return root(x=p[x]);
	  }
	  bool isu(int x,int y){ //2
	    return root(x)==root(y);
	  }
	};
