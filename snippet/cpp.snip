snippet segtree 	
	
	template<typename T=int_fast64_t>
	struct segT{
	  vector<T>v;
	  using F=function<T(T,T)>;
	  F f;
	  T e;
	  int sz;
	  segT(int n){
	    f=[](T a,T b){return a+b;};
	    e=0;
	    sz=1;while(sz<n)sz*=2;
	    v.resize(2*sz-1,e);
	  }
	  segT(int n,T e,F f):e(e),f(f){
	    sz=1;while(sz<n)sz*=2;
	    v.resize(2*sz-1,e);
	  }
	  void add(int x,T val){
	    x+=sz-1;
	    v[x]=f(v[x],val);
	    while(x>0){
	      x=(x-1)/2;
	      v[x]=f(v[2*x+1],v[2*x+2]);
	    }
	  }
	  void update(int x,T val){
	    x+=sz-1;
	    v[x]=val;
	    while(x>0){
	      x=(x-1)/2;
	      v[x]=f(v[2*x+1],v[2*x+2]);
	    }
	  }
	  T sum(int a,int b,int l=0,int r=-1,int k=0){
	    if(r==-1)r=sz;
	    if(a<=l&&r<=b)return v[k];
	    if(b<=l||r<=a)return e;
	    T lval=sum(a,b,l,(l+r)/2,2*k+1);
	    T rval=sum(a,b,(l+r)/2,r,2*k+2);
	    return f(lval,rval);
	  }
	};
snippet sm 	
	
	struct SM{
	  vector<vector<int>>m;
	  int N;
	  SM(vector<vector<int>>m):m(m),N(m.size()){};
	  SM operator+(SM obj){
	    SM res(vector<vector<int>>(N,vector<int>(N,0)));
	    for(int i=0;i<N;i++){
	      for(int j=0;j<N;j++){
	        res.m[i][j]=this->m[i][j]+obj.m[i][j];
	      }
	    }
	    return res;
	  }
	  SM operator*(SM obj){
	    SM res(vector<vector<int>>(N,vector<int>(N,0)));
	    for(int i=0;i<N;i++){
	      for(int j=0;j<N;j++){
	        for(int k=0;k<N;k++){
	          res.m[i][j]+=this->m[i][k]*obj.m[k][j];
	        }
	      }
	    }
	    return res;
	  }
	  SM pow(int n){
	    if(n==0){
	      vector<vector<int>>e(N,vector<int>(N,0));
	      for(int i=0;i<N;i++)e[i][i]=1;
	      return SM(e);
	    }
	    SM res(vector<vector<int>>(N,vector<int>(N)));
	    if(n%2)return (*this)*pow(n-1);
	    else{
	      SM half=pow(n/2);
	      return half*half;
	    }
	  }
	};
snippet uf 	
	
	struct UF{
	  vector<int>p; //p[i]=$B%N!<%I(Bi$B$N?F(B
	  vector<int>r; //rank[i]=$B%N!<%I(Bi$B$N%i%s%/(B
	  UF(int sz){
	    r.resize(sz,0);
	    p.resize(sz);
	    for(int i=0;i<sz;i++)p[i]=i;
	  }
	  void u(int x,int y){ //1
	    x=root(x);
	    y=root(y);
	    if(r[x]==r[y])r[x]++;
	    if(r[x]>r[y])p[y]=x;
	    else p[x]=y;
	  }
	  int root(int x){
	    if(p[x]==x)return x;
	    return root(x=p[x]);
	  }
	  bool isu(int x,int y){ //2
	    return root(x)==root(y);
	  }
	};
snippet dp_lis 	
	
	template<typename T,T inf>
	int lis(vector<T>v){
	  int N=v.size();
	  vector<T>dp(N,inf);
	  for(int i=0;i<N;i++){
	    int l=-1,r=N,m;
	    while(r-l>1){
	      m=(r+l)/2;
	      if(dp[m]<v[i])l=m;
	      else r=m;
	    }
	    dp[r]=min(v[i],dp[r]);
	  }
	  int res=0;
	  for(int i=0;i<N;i++)if(dp[i]!=inf)res=i;
	  return res+1;
	}
	
	
	int main(){
	  int N;
	  cin>>N;
	  vector<int>A(N);
	  for(int i=0;i<N;i++)cin>>A[i];
	  cout<<lis<int,INT_MAX>(A)<<endl;
	  return 0;
	}
snippet flow_fordfulkerson 	
	
	
	struct edge{
	  int to,cap,rev;
	};
	
	struct Flow{
	  vector<vector<edge>>G;
	  vector<bool>used;
	  Flow(vector<vector<edge>>g){
	    int N=g.size();
	    used.resize(N,false);
	    G.resize(N);
	    for(int i=0;i<N;i++){
	      for(auto it:g[i])add_edge(i,it.to,it.cap);
	    }
	  };
	  void add_edge(int from,int to,int cap){
	    G[from].push_back({to,cap,(int)G[to].size()});
	    G[to].push_back({from,0,(int)G[from].size()-1});
	  }
	  int max_flow(int s,int g){
	    int flow=0;
	    while(true){
	      fill(used.begin(),used.end(),false);
	      int f=dfs(s,g,INF);
	      if(f==0)return flow;
	      flow+=f;
	    }
	  }
	  int dfs(int s,int g,int val){
	    if(s==g)return val;
	    used[s]=true;
	    for(auto&e:G[s]){
	      if(!used[e.to]&&e.cap>0){
	        int d=dfs(e.to,g,min(val,e.cap));
	        if(d>0){
	          e.cap-=d;
	          G[e.to][e.rev].cap+=d;
	          return d;
	        }
	      }
	    }
	    return 0;
	  }
	};
snippet graph_bellman_ford 	
	
	struct E{
	  int to;
	  int from;
	  int cost;
	};
	
	vector<int_fast64_t>bellman_ford(vector<E>g,int n,int s,int_fast64_t inf){
	  vector<int_fast64_t>d(n,inf);
	  d[s]=0;
	  for(int i=0;i<n-1;i++){
	    for(auto e:g){
	      if(d[e.from]==inf)continue;
	      d[e.to]=min(d[e.to],d[e.from]+e.cost);
	    }
	  }
	  for(auto e:g){
	    if(d[e.from]==inf)continue;
	    if(d[e.from]+e.cost<d[e.to])return vector<int_fast64_t>();
	  }
	  return d;
	}
snippet graph_dijkstra 	
	
	struct E{
	  int to;
	  int_fast64_t cost;
	};
	
	vector<int_fast64_t>dijkstra(vector<vector<E>>g,int s,int_fast64_t inf){
	  vector<int_fast64_t>d(g.size(),inf);
	  using T=pair<int_fast64_t,int>;
	  using C=vector<T>;
	  using Cmp=greater<T>;
	  priority_queue<T,C,Cmp>q; 
	  d[s]=0;
	  q.push({d[s],s});
	  while(!q.empty()){
	    int_fast64_t cost=q.top().first;
	    int from=q.top().second;
	    q.pop();
	    if(d[from]!=cost)continue;
	    for(auto e:g[from]){
	      int_fast64_t next_cost=e.cost+cost;
	      if(d[e.to]>next_cost){
	        d[e.to]=next_cost;
	        q.push({d[e.to],e.to});
	      }
	    }
	  }
	  return d;
	}
snippet graph_prim 	
	
	struct E{
	  int to;
	  int_fast64_t cost;
	};
	
	vector<vector<E>>prim(vector<vector<E>>g){
	  vector<vector<E>>res(g.size());
	  using T=tuple<int_fast64_t,int,int>;
	  using C=vector<T>;
	  using Cmp=greater<T>;
	  priority_queue<T,C,Cmp>q;
	  q.push(T(0,0,-1));
	  vector<bool>used(g.size(),false);
	  while(!q.empty()){
	    int_fast64_t cost=get<0>(q.top());
	    int now=get<1>(q.top());
	    int par=get<2>(q.top());
	    q.pop();
	    if(used[now])continue;
	    used[now]=true;
	    if(par!=-1)res[par].push_back({now,cost});
	    for(auto e:g[now]){
	      q.push(T(e.cost,e.to,now));
	    }
	  }
	  return res;
	}
snippet math_gcd 	
	
	
	int_fast64_t gcd(int_fast64_t a,int_fast64_t b){
	  if(b==0)return a;
	  return gcd(b,a%b);
	}
snippet math_lcm 	
	
	int_fast64_t gcd(int_fast64_t a,int_fast64_t b){
	  if(b==0)return a;
	  return gcd(b,a%b);
	}
	
	int_fast64_t lcm(int_fast64_t a,int_fast64_t b){
	  return a*b/gcd(a,b);
	}
snippet math_modcomb 	
	
	template<uint_fast64_t m>
	struct Mcomb{
	  using i64=uint_fast64_t;
	  vector<i64>f;  //$B3,>h(B
	  vector<i64>finv; //$B3,>h$N5U85(B
	  vector<i64>inv;  //$B5U85(B
	
	  Mcomb(i64 max){
	    f.resize(max+1,0);
	    finv.resize(max+1,0);
	    inv.resize(max+1,0);
	    f[0]=f[1]=1;
	    finv[0]=finv[1]=1;
	    inv[1]=1;
	    for(int i=2;i<=max;i++){
	      f[i]=(f[i-1]*i%m)%m;
	      inv[i]=m-inv[m%i]*(m/i)%m;
	      finv[i]=finv[i-1]*inv[i]%m;
	    }
	  }
	
	  //nCr=n!/r!(n-r)!
	  i64 slove(i64 n,i64 r){
	    if(n<r)return 0;
	    if(n<0||r<0)return 0;
	    return f[n]*(finv[r]*finv[n-r]%m)%m;
	  }
	};
snippet math_modint 	
	
	template<uint_fast64_t mod>
	struct modint{
	  using i64=int_fast64_t;
	  i64 a;
	  constexpr modint(const i64 x=0) noexcept:a(x%mod){}
	
	  constexpr modint operator+(const modint obj)const noexcept{return modint(*this)+=obj;}
	  constexpr modint operator-(const modint obj)const noexcept{return modint(*this)-=obj;}
	  constexpr modint operator*(const modint obj)const noexcept{return modint(*this)*=obj;}
	  constexpr modint operator/(const modint obj)const noexcept{return modint(*this)/=obj;}
	
	  constexpr modint&operator+=(const modint obj)noexcept{
	    a+=obj.a;
	    if(a>=mod)a-=mod;
	    return *this;
	  }
	  constexpr modint&operator++(const modint obj)noexcept{
	    a++;
	    if(a>=mod)a-=mod;
	    return *this;
	  } 
	  constexpr modint&operator-=(const modint obj)noexcept{
	    if(a<obj.a)a+=mod;
	    a-=obj.a;
	    return *this;
	  }
	  constexpr modint&operator--(const modint obj)noexcept{
	    if(a<1)a+=mod;
	    a--;
	    return *this;
	  } 
	  constexpr modint&operator*=(const modint obj)noexcept{
	    a=a*obj.a%mod;
	    return *this;
	  }
	  constexpr modint&operator/=(modint obj)noexcept{
	    //a^(-1)=a^(mod-2)
	    i64 exp=mod-2;
	    while(exp){
	      if(exp%2)*this*=obj;
	      obj*=obj;
	      exp/=2;
	    }
	    return *this;
	  }
	
	  friend ostream&operator<<(ostream&os,const modint&obj)noexcept{
	    return os<<obj.a;
	  }
	  friend istream&operator<<(istream&is,const modint&obj)noexcept{
	    i64 i;
	    obj=modint<mod>(i);
	    return(is);
	  }
	};
snippet math_modpow 	
	
	template<uint_fast64_t m>
	int_fast64_t mpow(int_fast64_t x,int_fast64_t n){
	  using i64=int_fast64_t;
	  if(x==0)return 1;
	  if(x%2)return ((n%m)*(mpow<m>(n,x-1)%m))%m;
	  else {
	    i64 half=mpow<m>(n,x/2)%m;
	    return (half*half)%m;
	  }
	}
snippet math_prime 	
	
	bool isprime(int_fast64_t x){
	  for(int i=0;i*i<=x;i++){
	    if(x%i==0)return false;
	  }
	  return true;
	}
	
	map<int_fast64_t,int>prime_factor(int_fast64_t x){
	  map<int_fast64_t,int>res;
	  for(int_fast64_t i=2;i*i<=x;i++){
	    while(x%i==0){
	      res[i]++;
	      x/=i;
	    }
	  }
	  if(x!=1)res[x]=1;
	  return res;
	}
	
	vector<bool>eratosthenes(int n){
	  vector<bool>res(n+1,true);
	  res[0]=res[1]=false;
	  for(int i=2;i<=n;i++){
	    if(res[i])for(int j=i+i;j<=n;j+=i){
	      res[j]=false;
	    }
	  }
	  return res;
	}
snippet others_doubling 	
	
	struct Doubling{
	  vector<vector<int>>table;
	  int log;
	  int sz;
	  //sz:Ë¶ÅÁ¥†Êï∞ lim:ÊúÄÂ§ß„ÅÆÊï∞
	  Doubling(int sz,int64_t lim):sz(sz),log(64-__builtin_clzll(lim)){
	    table.resize(sz,vector<int>(log,-1));
	  }
	  void set_next(int now,int next){
	    table[now][0]=next;
	  }
	  void build(){
	    for(int j=0;j<log-1;j++){
	      for(int i=0;i<sz;i++){
	        if(table[i][j]==-1)table[i][j+1]=-1;
	        else table[i][j+1]=table[table[i][j]][j]; //i„ÅÆ2^jÂÖà„ÅÆ2^jÂÖà->i„ÅÆ2^(j+1)ÂÖà
	      }
	    }
	  }
	  int query(int x,int64_t t){
	    for(int i=log-1;i>=0;i--){
	      if((t>>i)&1)x=table[x][i];
	    }
	    return x;
	  }
	};
snippet string_RH 	
	
	vector<int> RH(string S,string T){
	  int SN=S.size();
	  int TN=T.size();
	  int_fast64_t b=9973; 
	  vector<int_fast64_t>mod={1000000007LL,1000000009LL,1000000021LL}; 
	  int M=mod.size();
	  vector<int_fast64_t>s(M,0);
	  vector<int_fast64_t>t(M,0);
	  vector<int_fast64_t>a(M,1);
	  for(int i=0;i<TN;i++){
	    for(int j=0;j<M;j++){
	      a[j]=(a[j]*b)%mod[j];
	    }
	  }
	  for(int i=0;i<TN;i++){
	    for(int j=0;j<M;j++){
	      s[j]=((s[j]*b)%mod[j]+S[i])%mod[j];
	    }
	  }
	  for(int i=0;i<TN;i++){
	    for(int j=0;j<M;j++){
	      t[j]=((t[j]*b)%mod[j]+T[i])%mod[j];
	    }
	  }
	  vector<int>res;
	  bool ok=true;
	  for(int i=0;i<M;i++)if(s[i]!=t[i])ok=false;
	  if(ok)res.push_back(0);
	  for(int i=0;i+TN<SN;i++){
	    ok=true;
	    for(int j=0;j<M;j++){
	      s[j]=((s[j]*b)%mod[j]-(S[i]*a[j])%mod[j])%mod[j];
	      if(s[j]<0)s[j]+=mod[j];
	      s[j]=(s[j]+S[i+TN])%mod[j];
	      if(s[j]!=t[j])ok=false;
	    }
	    if(ok)res.push_back(i+1);
	  }
	  return res;
	}
snippet tree_dlca 	
	
	struct Doubling{
	  vector<vector<int>>table;
	  int log;
	  int sz;
	  //sz:Ë¶ÅÁ¥†Êï∞ lim:ÊúÄÂ§ß„ÅÆÊï∞
	  Doubling(int sz,int64_t lim):sz(sz),log(64-__builtin_clzll(lim)){
	    table.resize(sz,vector<int>(log,-1));
	  }
	  void set_next(int now,int next){
	    table[now][0]=next;
	  }
	  void build(){
	    for(int j=0;j<log-1;j++){
	      for(int i=0;i<sz;i++){
	        if(table[i][j]==-1)table[i][j+1]=-1;
	        else table[i][j+1]=table[table[i][j]][j]; //i„ÅÆ2^jÂÖà„ÅÆ2^jÂÖà->i„ÅÆ2^(j+1)ÂÖà
	      }
	    }
	  }
	};
	
	struct DLCA{
	  int r;
	  vector<int>par;
	  vector<int>dep;
	  vector<vector<int>>g;
	  Doubling*d;
	  DLCA(vector<vector<int>>g,int r):g(g),r(r){
	    int N=g.size();
	    par.resize(N,0);
	    dep.resize(N,0);
	    d=new Doubling(N,N);
	    dfs(r,-1,0);
	    for(int i=0;i<N;i++)d->set_next(i,par[i]);
	    d->build();
	  }
	  void dfs(int x,int p,int val){
	    par[x]=p;
	    dep[x]=val;
	    for(auto it:g[x]){
	      if(it!=p)dfs(it,x,val+1);
	    }
	  }
	  int query(int x,int y){
	    if(dep[x]<dep[y])swap(x,y);
	    for(int i=d->log-1;i>=0;i--){
	      if(((dep[x]-dep[y])>>i)&1)x=d->table[x][i];
	    }
	    if(x==y)return x;
	    for(int i=d->log-1;i>=0;i--){
	      if(d->table[x][i]!=d->table[y][i]){
	        x=d->table[x][i];
	        y=d->table[y][i];
	      }
	    }
	    return d->table[x][0];
	  }
	};
snippet tree_lca 	
	
	struct LCA{
	  int r; 
	  vector<int>par;
	  vector<int>d;
	  vector<vector<int>>g;
	  LCA(vector<vector<int>>g,int r):g(g),r(r){
	    int N=g.size();
	    par.resize(N,0);
	    d.resize(N,0);
	    dfs(r,-1,0);
	  }
	  void dfs(int x,int p,int val){
	    par[x]=p;
	    d[x]=val;
	    for(auto it:g[x]){
	      if(it!=p)dfs(it,x,val+1);
	    }
	  }
	  int query(int x,int y){
	    while(d[x]>d[y])x=par[x];
	    while(d[x]<d[y])y=par[y];
	    while(x!=y)x=par[x],y=par[y];
	    return x;
	  }
	};
